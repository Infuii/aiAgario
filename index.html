<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Agar.io Clone</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Arial", sans-serif;
      }

      body {
        overflow: hidden;
        background: #f0f0f0;
        position: relative;
      }

      #gameCanvas {
        display: block;
        background: #f8f8f8;
        position: absolute;
        top: 0;
        left: 0;
      }

      #menu {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 450px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 40px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 10;
        transition: all 0.3s ease;
      }

      #menu h1 {
        font-size: 48px;
        margin-bottom: 25px;
        color: #333;
        text-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      #menu input {
        width: 100%;
        padding: 15px;
        margin-bottom: 20px;
        border: 2px solid #ddd;
        border-radius: 10px;
        font-size: 18px;
        outline: none;
        transition: border 0.3s;
      }

      #menu input:focus {
        border-color: #3498db;
      }

      #menu button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 10px;
        background: #3498db;
        color: white;
        font-size: 20px;
        cursor: pointer;
        transition: background 0.3s;
        margin-bottom: 10px;
      }

      #menu button:hover {
        background: #2980b9;
      }

      .mode-selection {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .mode-btn {
        flex: 1;
        padding: 10px 5px;
        margin: 0 5px 5px 5px;
        border: 2px solid #ddd;
        border-radius: 8px;
        background: #f8f8f8;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 80px;
      }

      .mode-btn.active {
        background: #3498db;
        color: white;
        border-color: #2980b9;
      }

      .team-selection {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
      }

      .team-btn {
        flex: 1;
        padding: 15px 5px;
        margin: 0 5px;
        border: 2px solid #ddd;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        color: white;
        font-weight: bold;
      }

      .team-btn.red {
        background: rgba(255, 0, 0, 0.7);
        border-color: darkred;
      }

      .team-btn.green {
        background: rgba(0, 128, 0, 0.7);
        border-color: darkgreen;
      }

      .team-btn.blue {
        background: rgba(0, 0, 255, 0.7);
        border-color: darkblue;
      }

      .team-btn.active {
        box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.8) inset;
        transform: scale(1.05);
      }

      #leaderboard {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 200px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        z-index: 5;
      }

      #leaderboard h2 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 18px;
        color: #333;
      }

      #leaderboard ul {
        list-style: none;
      }

      #leaderboard li {
        padding: 5px 0;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
      }

      #leaderboard li:last-child {
        border-bottom: none;
      }

      #leaderboard .team-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 5px;
      }

      #leaderboard .player-position {
        position: absolute;
        bottom: 10px;
        width: calc(100% - 30px);
        text-align: center;
        padding: 5px 0;
        font-weight: bold;
        border-top: 1px solid #eee;
      }

      #team-dominance {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 200px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        z-index: 5;
        display: none;
      }

      #team-dominance h2 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 18px;
        color: #333;
      }

      #team-pie-chart {
        width: 150px;
        height: 150px;
        margin: 0 auto;
        position: relative;
      }

      .team-legend {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
      }

      .legend-item {
        display: flex;
        align-items: center;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        margin-right: 5px;
      }

      #team-stats {
        position: absolute;
        top: 250px;
        left: 20px;
        width: 200px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        z-index: 5;
        display: none;
      }

      #team-stats h2 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 18px;
        color: #333;
      }

      .team-bar {
        height: 20px;
        margin-bottom: 5px;
        border-radius: 3px;
        position: relative;
      }

      .team-bar-label {
        position: absolute;
        right: 5px;
        top: 0;
        color: white;
        font-weight: bold;
        font-size: 12px;
        line-height: 20px;
        text-shadow: 0 0 2px black;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        z-index: 5;
      }

      #controls h3 {
        margin-bottom: 5px;
      }

      #controls p {
        margin: 5px 0;
        font-size: 14px;
      }

      #admin-panel {
        position: relative;
        bottom: 20px;
        right: 20px;
        width: 250px;
        background: rgba(255, 255, 255, 0.95); /* More visible background */
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* Stronger shadow */
        z-index: 100; /* Ensure it's above other elements */
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        border: 2px solid #3498db; /* Add border to make it more visible */
      }

      /* Make admin controls more visible */

      #admin-panel h3 {
        text-align: center;
        margin-bottom: 10px;
        color: #333;
      }

      .admin-control {
        margin-bottom: 10px;
      }

      .admin-control label {
        display: block;
        margin-bottom: 5px;
        font-size: 14px;
      }

      .admin-control input[type="range"] {
        width: 100%;
      }

      .admin-control input[type="checkbox"] {
        margin-right: 5px;
      }

      .admin-control .value {
        float: right;
        font-weight: bold;
      }

      .admin-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
      }

      .admin-buttons button {
        flex: 1;
        margin: 0 5px;
        padding: 8px;
        border: none;
        border-radius: 5px;
        background: #3498db;
        color: white;
        cursor: pointer;
      }

      .admin-buttons button:hover {
        background: #2980b9;
      }

      /* Death animation container */
      #death-animation {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
        display: none;
      }

      /* Big Pellet style */
      .big-pellet {
        border: 3px solid rgba(255, 255, 255, 0.5);
        box-shadow: 0 0 10px rgba(255, 255, 0, 0.7);
      }

      /* Enhanced blob styling */
      .blob {
        filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.3));
      }

      /* Improved pellet glow effect */
      .pellet-glow {
        filter: blur(5px);
        mix-blend-mode: screen;
      }

      /* Enhanced virus appearance */
      .virus {
        filter: drop-shadow(0 0 15px rgba(0, 255, 0, 0.4));
      }

      /* Smooth animations */
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      .admin-section {
        margin-bottom: 15px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.08);
        border-radius: 8px;
        border: 1px solid #ddd;
      }

      .admin-section h4 {
        margin-bottom: 10px;
        color: #333;
        font-size: 14px;
        text-transform: uppercase;
      }

      .admin-control {
        margin-bottom: 8px;
      }

      .admin-control input[type="range"] {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        -webkit-appearance: none;
        background: #ddd;
      }

      .admin-control input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #3498db;
        cursor: pointer;
        transition: background 0.2s;
      }

      .admin-control input[type="range"]::-webkit-slider-thumb:hover {
        background: #2980b9;
      }

      .admin-buttons button {
        padding: 8px 12px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        background: #3498db;
        color: white;
        cursor: pointer;
        transition: background 0.2s;
      }

      .admin-buttons button:hover {
        background: #2980b9;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="death-animation"></div>

    <div id="menu">
      <h1>Blob.io</h1>
      <input
        type="text"
        id="playerName"
        placeholder="Enter your name"
        maxlength="15"
      />

      <h3>Game Mode</h3>
      <div class="mode-selection">
        <div class="mode-btn active" data-mode="ffa">FFA</div>
        <div class="mode-btn" data-mode="teams">Teams</div>
        <div class="mode-btn" data-mode="admin">Admin Mode</div>
      </div>

      <div id="team-selection" style="display: none">
        <h3>Select Team</h3>
        <div class="team-selection">
          <div class="team-btn red active" data-team="red">Red</div>
          <div class="team-btn green" data-team="green">Green</div>
          <div class="team-btn blue" data-team="blue">Blue</div>
        </div>
      </div>

      <button id="playButton">Play</button>
    </div>

    <div id="leaderboard" style="display: none">
      <h2>Leaderboard</h2>
      <ul id="leaderboardList"></ul>
      <div class="player-position" id="playerPosition"></div>
    </div>

    <div id="team-dominance" style="display: none">
      <h2>Team Dominance</h2>
      <div id="team-pie-chart"></div>
      <div class="team-legend">
        <div class="legend-item">
          <div class="legend-color" style="background-color: red"></div>
          <span>Red</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: green"></div>
          <span>Green</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: blue"></div>
          <span>Blue</span>
        </div>
      </div>
    </div>

    <div id="team-stats" style="display: none">
      <h2>Team History</h2>
      <div id="team-bars">
        <!-- Bars will be added dynamically -->
      </div>
    </div>

    <div id="controls" style="display: none">
      <h3>Controls:</h3>
      <p>Move: WASD or Arrow Keys</p>
      <p>Split: Spacebar</p>
      <p>Eject Mass: E</p>
    </div>

    <div id="admin-panel" style="display: none">
      <h3>Admin Controls</h3>

      <div class="admin-section">
        <h4>World Settings</h4>
        <div class="admin-control">
          <label
            >World Size
            <span class="value" id="world-size-value">4000</span></label
          >
          <input
            type="range"
            id="world-size"
            min="2000"
            max="8000"
            step="500"
            value="4000"
          />
        </div>

        <div class="admin-control">
          <label
            >Grid Spacing
            <span class="value" id="grid-spacing-value">40</span></label
          >
          <input
            type="range"
            id="grid-spacing"
            min="20"
            max="100"
            step="10"
            value="40"
          />
        </div>
      </div>

      <div class="admin-section">
        <h4>Player Settings</h4>
        <div class="admin-control">
          <label
            >Start Mass
            <span class="value" id="start-mass-value">10</span></label
          >
          <input
            type="range"
            id="start-mass"
            min="10"
            max="1000"
            step="10"
            value="10"
          />
        </div>

        <div class="admin-control">
          <label
            >Min Speed <span class="value" id="min-speed-value">2</span></label
          >
          <input
            type="range"
            id="min-speed"
            min="1"
            max="10"
            step="0.5"
            value="2"
          />
        </div>

        <div class="admin-control">
          <label
            >Max Speed <span class="value" id="max-speed-value">5</span></label
          >
          <input
            type="range"
            id="max-speed"
            min="3"
            max="15"
            step="0.5"
            value="5"
          />
        </div>

        <div class="admin-control">
          <label
            >Base Size <span class="value" id="base-size-value">30</span></label
          >
          <input
            type="range"
            id="base-size"
            min="20"
            max="100"
            step="5"
            value="30"
          />
        </div>
      </div>

      <div class="admin-section">
        <h4>Split Settings</h4>
        <div class="admin-control">
          <label
            >Split Force
            <span class="value" id="split-force-value">10</span></label
          >
          <input
            type="range"
            id="split-force"
            min="5"
            max="30"
            step="1"
            value="10"
          />
        </div>

        <div class="admin-control">
          <label
            >Split Delay (ms)
            <span class="value" id="split-delay-value">30000</span></label
          >
          <input
            type="range"
            id="split-delay"
            min="5000"
            max="60000"
            step="5000"
            value="30000"
          />
        </div>

        <div class="admin-control">
          <label
            >Max Splits
            <span class="value" id="max-splits-value">16</span></label
          >
          <input
            type="range"
            id="max-splits"
            min="2"
            max="32"
            step="2"
            value="16"
          />
        </div>
      </div>

      <div class="admin-section">
        <h4>Game Elements</h4>
        <div class="admin-control">
          <label
            >Pellet Count
            <span class="value" id="pellet-count-value">2000</span></label
          >
          <input
            type="range"
            id="pellet-count"
            min="100"
            max="5000"
            step="100"
            value="2000"
          />
        </div>

        <div class="admin-control">
          <label
            >Virus Count
            <span class="value" id="virus-count-value">15</span></label
          >
          <input
            type="range"
            id="virus-count"
            min="0"
            max="50"
            step="1"
            value="15"
          />
        </div>

        <div class="admin-control">
          <label
            >Exp Virus Count
            <span class="value" id="exp-virus-count-value">5</span></label
          >
          <input
            type="range"
            id="exp-virus-count"
            min="0"
            max="20"
            step="1"
            value="5"
          />
        </div>

        <div class="admin-control">
          <label
            >AI Count <span class="value" id="ai-count-value">15</span></label
          >
          <input
            type="range"
            id="ai-count"
            min="0"
            max="50"
            step="1"
            value="15"
          />
        </div>
      </div>

      <div class="admin-section">
        <h4>Speed Multipliers</h4>
        <div class="admin-control">
          <label
            >Player Speed
            <span class="value" id="player-speed-value">3</span></label
          >
          <input
            type="range"
            id="player-speed"
            min="1"
            max="10"
            step="0.5"
            value="3"
          />
        </div>

        <div class="admin-control">
          <label
            >AI Speed <span class="value" id="ai-speed-value">3</span></label
          >
          <input
            type="range"
            id="ai-speed"
            min="1"
            max="10"
            step="0.5"
            value="3"
          />
        </div>
      </div>

      <div class="admin-section">
        <h4>Special Features</h4>
        <div class="admin-control">
          <label>
            <input type="checkbox" id="big-pellets" /> Enable Big Pellets
          </label>
        </div>

        <div class="admin-control">
          <label>
            <input type="checkbox" id="no-collision" /> No Collision
          </label>
        </div>

        <div class="admin-control">
          <label>
            <input type="checkbox" id="rainbow-mode" /> Rainbow Mode
          </label>
        </div>
      </div>

      <div class="admin-buttons">
        <button id="clear-viruses">Clear Viruses</button>
        <button id="add-mass">Add 500 Mass</button>
        <button id="reset-settings">Reset Settings</button>
      </div>
    </div>

    <script>
      // Game Constants (some will be configurable in admin mode)
      let WORLD_SIZE = 4000;
      let GRID_SPACING = 40;
      let PELLET_COUNT = 2000;
      let AI_COUNT = 15;
      let VIRUS_COUNT = 15;
      let EXP_VIRUS_COUNT = 5;
      const MIN_SCALE = 0.5;
      const MAX_SCALE = 1.0;
      let MIN_SPEED = 2;
      let MAX_SPEED = 5;
      let PLAYER_SPEED_MULTIPLIER = 125.0; // Changed from 125.0 to match AI speed
      let AI_SPEED_MULTIPLIER = 2.0;
      const MIN_BLOB_SIZE = 20;
      const MAX_BLOB_SIZE = 2000;
      let BASE_SIZE = 30;
      let START_MASS = 10;
      const PELLET_SIZE = 10;
      const BIG_PELLET_SIZE = 25;
      const BIG_PELLET_MASS = 100;
      const VIRUS_SIZE = 100;
      const EXP_VIRUS_SIZE = 120;
      const SPLIT_DELAY = 30000; // 30 seconds
      const MAX_SPLITS = 16; // Increased from 10
      let SPLIT_FORCE = 10; // Adjustable in admin mode
      const COVERAGE_REQUIRED = 0.5; // Require 50% coverage to eat another blob
      const COLORS = [
        "#FF5733",
        "#33FF57",
        "#3357FF",
        "#FF33F5",
        "#F5FF33",
        "#33FFF5",
        "#FF3333",
        "#33FF33",
        "#3333FF",
        "#FF33FF",
        "#FFFF33",
        "#33FFFF",
        "#FF8333",
        "#83FF33",
        "#8333FF",
        "#FF33A8",
        "#A8FF33",
        "#33A8FF",
        "#FFA833",
        "#A833FF",
        "#33FFA8",
        "#A833FF",
        "#FFA833",
        "#33FFA8",
        "#A8FF33",
        "#FFA833",
        "#33FFA8",
        "#A8FF33",
        "#A833FF",
        "#33A8FF",
        "#FF33A8",
        "#A8FF33",
        "#33FF33",
        "#33FF33",
        "#33FF33",
        "#FF00FF",
      ];
      const TEAM_COLORS = {
        red: "#FF3333",
        green: "#33FF33",
        blue: "#3333FF",
      };
      const AI_NAMES = [
        "Blob Boss",
        "Cell Muncher",
        "Devourer",
        "Hungry Cell",
        "Mass Master",
        "Pellet Hunter",
        "Quantum Blob",
        "Rapid Cell",
        "Sphere Eater",
        "Tiny Terror",
        "Ultra Blob",
        "Vicious Cell",
        "Wet Willy",
        "Xenon Cell",
        "Yummy Blob",
        "Zigzag Cell",
        "Apex Blob",
        "Blob Knight",
        "Cell Wizard",
        "Daring Blob",
        "Alpha Cell",
        "Beta Blob",
        "Cosmic Cell",
        "Dark Matter",
        "Energy Eater",
        "Fusion Cell",
        "Gamma Blob",
        "Heavy Mass",
        "Ion Cell",
        "Jelly Giant",
        "Kinetic Blob",
        "Light Speed",
        "Mega Mass",
        "Neutron Cell",
        "Orbit Eater",
        "Plasma Blob",
        "Quark Cell",
        "Radiation",
        "Solar Cell",
        "Thunder Blob",
        "Universe Cell",
        "Void Walker",
        "Wave Rider",
        "X-Factor",
        "Yellow Giant",
        "Zero Point",
        "Amoeba King",
        "Bio Hazard",
        "Cell Storm",
        "Deep Space",
        "Echo Blob",
        "Flame Cell",
        "Ghost Blob",
        "Hyper Mass",
        "Ice Giant",
        "Jupiter Cell",
        "Karma Blob",
        "Lunar Mass",
        "Mars Walker",
        "Nova Blast",
        "Omega Cell",
        "Proton Blob",
        "Quantum Dot",
        "Red Giant",
        "Star Eater",
        "Titan Cell",
        "Uranium Blob",
        "Viral Mass",
        "Warp Speed",
        "X-Ray Cell",
        "Yeti Blob",
        "Zen Master",
        "Acid Pool",
        "Binary Star",
        "Chaos Theory",
        "Delta Force",
        "Echo Chamber",
        "Fusion Core",
        "Gravity Well",
        "Helium Heart",
        "Infinity Edge",
        "Jet Stream",
        "Kelvin Cold",
        "Lava Flow",
        "Meteor Strike",
        "Nebula Core",
        "Ozone Layer",
        "Pulsar Push",
        "Quasar Quest",
        "Radiant Sun",
        "Solar Wind",
        "Time Warp",
        "Unity Mass",
        "Vertex Void",
        "Worm Hole",
        "Xenon Flash",
        "Yield Sign",
        "Zero Cool",
        "Atomic Blob",
        "Blob Storm",
        "Cell Shock",
        "Data Blob",
        "Elite Mass",
        "Fast Food",
        "Giga Blob",
        "Hack Attack",
        "Iron Giant",
        "Jolt Jump",
        "Kilo Blob",
        "Laser Shot",
        "Micro Mass",
        "Nano Blob",
        "Octo Cell",
        "Pixel Push",
        "Quick Split",
        "Rage Quit",
        "Super Cell",
        "Tech Blob",
        "Unit Mass",
        "Virus King",
        "Web Crawler",
        "Xeno Corp",
        "Yoga Mass",
        "Zerg Rush",
        "Arc Light",
        "Bob Blob",
        "Cool Cell",
        "Dot Com",
        "Epic Blob",
        "Fun Size",
        "Good Game",
        "Hot Shot",
        "Ice Cold",
        "Just Blob",
        "Kind Cell",
        "Lucky Star",
        "Mega Byte",
        "Ninja Cell",
        "Open Source",
        "Pixel Perfect",
        "Quick Draw",
        "Rapid Fire",
        "Super Sonic",
        "Tech Support",
        "Ultra Violet",
        "Viral Video",
        "Web Master",
        "X Factor",
        "Yin Yang",
        "Zig Zag",
        "Zombie",
        "Big Boy",
        "Small Fry",
        "Good Boy",
      ];

      const DEFAULT_SETTINGS = {
        WORLD_SIZE: 4000,
        GRID_SPACING: 40,
        PELLET_COUNT: 2000,
        AI_COUNT: 15,
        VIRUS_COUNT: 15,
        EXP_VIRUS_COUNT: 5,
        MIN_SPEED: 2,
        MAX_SPEED: 5,
        PLAYER_SPEED_MULTIPLIER: 125.0,
        AI_SPEED_MULTIPLIER: 2.0,
        BASE_SIZE: 30,
        START_MASS: 10,
        SPLIT_FORCE: 10,
        enableBigPellets: false,
        noCollision: false,
        rainbowMode: false,
      };

      // Admin mode variables
      let enableBigPellets = false;
      let noCollision = false;
      let rainbowMode = false;

      // Game Variables
      let canvas, ctx;
      let player = null;
      let playerName = "";
      let playerTeam = null;
      let blobs = [];
      let pellets = [];
      let viruses = [];
      let expViruses = [];
      let camera = { x: 0, y: 0, scale: 1 };
      let keys = { up: false, down: false, left: false, right: false };
      let lastFrameTime = 0;
      let gameStarted = false;
      let gameMode = "ffa"; // 'ffa', 'teams', or 'admin'
      let teamMass = { red: 0, green: 0, blue: 0 };
      let teamHistory = { red: [0], green: [0], blue: [0] };
      let teamHighScores = { red: 0, green: 0, blue: 0 };
      let historyUpdateInterval = null;
      let dyingCells = []; // For death animation
      let rainbowInterval = null; // For rainbow mode

      // Initialize game
      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");

        // Set canvas size
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Menu event listeners
        document
          .getElementById("playButton")
          .addEventListener("click", startGame);

        // Game mode selection
        const modeBtns = document.querySelectorAll(".mode-btn");
        modeBtns.forEach((btn) => {
          btn.addEventListener("click", function () {
            modeBtns.forEach((b) => b.classList.remove("active"));
            this.classList.add("active");
            gameMode = this.getAttribute("data-mode");

            // Show/hide team selection
            document.getElementById("team-selection").style.display =
              gameMode === "teams" ? "block" : "none";
          });
        });

        // Team selection
        const teamBtns = document.querySelectorAll(".team-btn");
        teamBtns.forEach((btn) => {
          btn.addEventListener("click", function () {
            teamBtns.forEach((b) => b.classList.remove("active"));
            this.classList.add("active");
            playerTeam = this.getAttribute("data-team");
          });
        });

        // Game controls
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);

        // Admin panel listeners
        setupAdminPanel();

        // Create initial world
        generateWorld();

        // Start render loop
        requestAnimationFrame(gameLoop);
      }

      // Set up admin panel controls
      function setupAdminPanel() {
        const controls = {
          "world-size": (value) => (WORLD_SIZE = parseInt(value)),
          "grid-spacing": (value) => (GRID_SPACING = parseInt(value)),
          "min-speed": (value) => (MIN_SPEED = parseFloat(value)),
          "max-speed": (value) => (MAX_SPEED = parseFloat(value)),
          "base-size": (value) => (BASE_SIZE = parseInt(value)),
          "split-force": (value) => (SPLIT_FORCE = parseInt(value)),
          "split-delay": (value) => (SPLIT_DELAY = parseInt(value)),
          "max-splits": (value) => (MAX_SPLITS = parseInt(value)),
          "pellet-count": (value) => (PELLET_COUNT = parseInt(value)),
          "virus-count": (value) => (VIRUS_COUNT = parseInt(value)),
          "exp-virus-count": (value) => (EXP_VIRUS_COUNT = parseInt(value)),
          "ai-count": (value) => (AI_COUNT = parseInt(value)),
          "start-mass": (value) => {
            START_MASS = parseInt(value);
            // If in admin mode and player exists, update player mass
            if (gameMode === "admin" && player) {
              for (let i = 0; i < player.blobs.length; i++) {
                player.blobs[i].mass = START_MASS;
                player.blobs[i].size = calculateSize(START_MASS);
              }
            }
          },
          "player-speed": (value) =>
            (PLAYER_SPEED_MULTIPLIER = parseFloat(value) / 3),
          "ai-speed": (value) => (AI_SPEED_MULTIPLIER = parseFloat(value) / 3),
        };

        // Set up event listeners for all controls
        Object.keys(controls).forEach((id) => {
          const slider = document.getElementById(id);
          const valueDisplay = document.getElementById(`${id}-value`);

          slider.addEventListener("input", function () {
            valueDisplay.textContent = this.value;
            controls[id](this.value);

            // If we're changing world size or grid spacing, regenerate the world
            if (id === "world-size" || id === "grid-spacing") {
              // Only regenerate if the game has started
              if (gameStarted) {
                generateWorld();
              }
            }

            // If we're changing AI count, update the AI population
            if (id === "ai-count" && gameStarted) {
              updateAICount();
            }

            // If we're changing virus counts, update virus population
            if (
              (id === "virus-count" || id === "exp-virus-count") &&
              gameStarted
            ) {
              updateVirusCounts();
            }

            // If we're changing pellet count, update pellet population
            if (id === "pellet-count" && gameStarted) {
              updatePelletCount();
            }

            // Save settings to localStorage
            localStorage.setItem(`admin_${id}`, this.value);
          });

          // Load saved settings
          const savedValue = localStorage.getItem(`admin_${id}`);
          if (savedValue !== null) {
            slider.value = savedValue;
            valueDisplay.textContent = savedValue;
            controls[id](savedValue);
          }
        });

        // Special features
        ["big-pellets", "no-collision", "rainbow-mode"].forEach((id) => {
          const checkbox = document.getElementById(id);
          checkbox.addEventListener("change", function () {
            window[id.replace(/-/g, "")] = this.checked;
            localStorage.setItem(`admin_${id}`, this.checked);

            // Handle rainbow mode toggle
            if (id === "rainbow-mode") {
              toggleRainbowMode(this.checked);
            }

            // Handle big pellets toggle
            if (id === "big-pellets" && this.checked && gameStarted) {
              // Add some big pellets when turned on
              for (let i = 0; i < PELLET_COUNT * 0.05; i++) {
                addBigPellet();
              }
            }
          });

          // Load saved settings
          const savedValue = localStorage.getItem(`admin_${id}`);
          if (savedValue !== null) {
            checkbox.checked = savedValue === "true";
            window[id.replace(/-/g, "")] = checkbox.checked;
          }
        });

        // Button handlers
        document
          .getElementById("clear-viruses")
          .addEventListener("click", function () {
            viruses = [];
            expViruses = [];
          });

        document
          .getElementById("add-mass")
          .addEventListener("click", function () {
            if (player && player.blobs) {
              for (let i = 0; i < player.blobs.length; i++) {
                player.blobs[i].mass += 500;
                player.blobs[i].size = calculateSize(player.blobs[i].mass);
              }
            }
          });

        // Reset settings button
        document
          .getElementById("reset-settings")
          .addEventListener("click", function () {
            if (confirm("Reset all admin settings to default values?")) {
              resetAdminSettings();
            }
          });
      }

      // Toggle rainbow mode on or off
      function toggleRainbowMode(enabled) {
        if (enabled) {
          if (rainbowInterval) {
            clearInterval(rainbowInterval);
          }

          rainbowInterval = setInterval(() => {
            // Change player color if player exists
            if (player && player.blobs) {
              const color = getRandomColor();
              for (let i = 0; i < player.blobs.length; i++) {
                player.blobs[i].color = color;
              }
            }

            // Change AI colors too for fun
            for (let i = 0; i < blobs.length; i++) {
              if (gameMode !== "teams" || !blobs[i].team) {
                const color = getRandomColor();
                for (let j = 0; j < blobs[i].blobs.length; j++) {
                  blobs[i].blobs[j].color = color;
                }
              }
            }
          }, 500);
        } else if (rainbowInterval) {
          clearInterval(rainbowInterval);
          rainbowInterval = null;
        }
      }

      // Update AI count to match admin settings
      function updateAICount() {
        const currentCount = blobs.filter((b) => b.isAI).length;

        if (currentCount < AI_COUNT) {
          // Add more AI
          for (let i = 0; i < AI_COUNT - currentCount; i++) {
            addNewAI();
          }
        } else if (currentCount > AI_COUNT) {
          // Remove excess AI
          let removed = 0;
          for (let i = blobs.length - 1; i >= 0; i--) {
            if (blobs[i].isAI) {
              blobs.splice(i, 1);
              removed++;
              if (removed >= currentCount - AI_COUNT) {
                break;
              }
            }
          }
        }
      }

      // Update virus counts to match admin settings
      function updateVirusCounts() {
        // Update regular viruses
        if (viruses.length < VIRUS_COUNT) {
          // Add more viruses
          for (let i = 0; i < VIRUS_COUNT - viruses.length; i++) {
            viruses.push({
              x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
              y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
              size: VIRUS_SIZE,
              mass: 200,
            });
          }
        } else if (viruses.length > VIRUS_COUNT) {
          // Remove excess viruses
          viruses.splice(VIRUS_COUNT, viruses.length - VIRUS_COUNT);
        }

        // Update experimental viruses
        if (expViruses.length < EXP_VIRUS_COUNT) {
          // Add more exp viruses
          for (let i = 0; i < EXP_VIRUS_COUNT - expViruses.length; i++) {
            const newVirus = {
              x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
              y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
              size: EXP_VIRUS_SIZE,
              mass: 300,
              pellets: [],
            };

            // Generate pellets around exp virus
            generateExpVirusPellets(newVirus, 20);
            expViruses.push(newVirus);
          }
        } else if (expViruses.length > EXP_VIRUS_COUNT) {
          // Remove excess exp viruses
          expViruses.splice(
            EXP_VIRUS_COUNT,
            expViruses.length - EXP_VIRUS_COUNT
          );
        }
      }

      // Update pellet count to match admin settings
      function updatePelletCount() {
        if (pellets.length < PELLET_COUNT) {
          // Add more pellets
          for (let i = 0; i < PELLET_COUNT - pellets.length; i++) {
            addPellet();
          }
        } else if (pellets.length > PELLET_COUNT) {
          // Remove excess pellets - keep any ejected mass
          let removed = 0;
          for (let i = pellets.length - 1; i >= 0; i--) {
            if (!pellets[i].isEjected) {
              pellets.splice(i, 1);
              removed++;
              if (removed >= pellets.length - PELLET_COUNT) {
                break;
              }
            }
          }
        }
      }

      // Reset admin settings to defaults
      function resetAdminSettings() {
        Object.keys(DEFAULT_SETTINGS).forEach((key) => {
          window[key] = DEFAULT_SETTINGS[key];
        });

        // Update UI to reflect default values
        document.getElementById("world-size").value =
          DEFAULT_SETTINGS.WORLD_SIZE;
        document.getElementById("world-size-value").textContent =
          DEFAULT_SETTINGS.WORLD_SIZE;

        document.getElementById("grid-spacing").value =
          DEFAULT_SETTINGS.GRID_SPACING;
        document.getElementById("grid-spacing-value").textContent =
          DEFAULT_SETTINGS.GRID_SPACING;

        document.getElementById("min-speed").value = DEFAULT_SETTINGS.MIN_SPEED;
        document.getElementById("min-speed-value").textContent =
          DEFAULT_SETTINGS.MIN_SPEED;

        document.getElementById("max-speed").value = DEFAULT_SETTINGS.MAX_SPEED;
        document.getElementById("max-speed-value").textContent =
          DEFAULT_SETTINGS.MAX_SPEED;

        document.getElementById("base-size").value = DEFAULT_SETTINGS.BASE_SIZE;
        document.getElementById("base-size-value").textContent =
          DEFAULT_SETTINGS.BASE_SIZE;

        document.getElementById("split-force").value =
          DEFAULT_SETTINGS.SPLIT_FORCE;
        document.getElementById("split-force-value").textContent =
          DEFAULT_SETTINGS.SPLIT_FORCE;

        document.getElementById("pellet-count").value =
          DEFAULT_SETTINGS.PELLET_COUNT;
        document.getElementById("pellet-count-value").textContent =
          DEFAULT_SETTINGS.PELLET_COUNT;

        document.getElementById("virus-count").value =
          DEFAULT_SETTINGS.VIRUS_COUNT;
        document.getElementById("virus-count-value").textContent =
          DEFAULT_SETTINGS.VIRUS_COUNT;

        document.getElementById("exp-virus-count").value =
          DEFAULT_SETTINGS.EXP_VIRUS_COUNT;
        document.getElementById("exp-virus-count-value").textContent =
          DEFAULT_SETTINGS.EXP_VIRUS_COUNT;

        document.getElementById("ai-count").value = DEFAULT_SETTINGS.AI_COUNT;
        document.getElementById("ai-count-value").textContent =
          DEFAULT_SETTINGS.AI_COUNT;

        document.getElementById("start-mass").value =
          DEFAULT_SETTINGS.START_MASS;
        document.getElementById("start-mass-value").textContent =
          DEFAULT_SETTINGS.START_MASS;

        document.getElementById("player-speed").value =
          DEFAULT_SETTINGS.PLAYER_SPEED_MULTIPLIER * 3;
        document.getElementById("player-speed-value").textContent =
          DEFAULT_SETTINGS.PLAYER_SPEED_MULTIPLIER * 3;

        document.getElementById("ai-speed").value =
          DEFAULT_SETTINGS.AI_SPEED_MULTIPLIER * 3;
        document.getElementById("ai-speed-value").textContent =
          DEFAULT_SETTINGS.AI_SPEED_MULTIPLIER * 3;

        document.getElementById("big-pellets").checked =
          DEFAULT_SETTINGS.enableBigPellets;
        document.getElementById("no-collision").checked =
          DEFAULT_SETTINGS.noCollision;
        document.getElementById("rainbow-mode").checked =
          DEFAULT_SETTINGS.rainbowMode;

        // Clear localStorage settings
        Object.keys(DEFAULT_SETTINGS).forEach((key) => {
          localStorage.removeItem(`admin_${key.toLowerCase()}`);
        });

        // Stop rainbow mode if active
        if (rainbowInterval) {
          clearInterval(rainbowInterval);
          rainbowInterval = null;
        }

        // Regenerate world with new settings if game is started
        if (gameStarted) {
          generateWorld();
          updateAICount();
        }
      }

      // Resize canvas to fit window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      // Generate initial world entities
      function generateWorld() {
        // Generate pellets
        pellets = [];
        for (let i = 0; i < PELLET_COUNT; i++) {
          addPellet();
        }

        // Generate viruses
        viruses = [];
        for (let i = 0; i < VIRUS_COUNT; i++) {
          viruses.push({
            x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
            y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
            size: VIRUS_SIZE,
            mass: 200,
          });
        }

        // Generate experimental viruses
        expViruses = [];
        for (let i = 0; i < EXP_VIRUS_COUNT; i++) {
          expViruses.push({
            x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
            y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
            size: EXP_VIRUS_SIZE,
            mass: 300,
            pellets: [],
          });

          // Generate pellets around exp virus
          generateExpVirusPellets(expViruses[i], 20);
        }
      }

      // Add a regular pellet
      function addPellet() {
        pellets.push({
          x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
          y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
          size: PELLET_SIZE,
          mass: 1,
          color: getRandomColor(),
          isBig: false,
        });
      }

      // Add a big pellet (admin mode)
      function addBigPellet() {
        pellets.push({
          x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
          y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
          size: BIG_PELLET_SIZE,
          mass: BIG_PELLET_MASS,
          color: getRandomColor(),
          isBig: true,
        });
      }

      // Generate pellets around experimental virus
      function generateExpVirusPellets(virus, count) {
        if (!virus.pellets) {
          virus.pellets = [];
        }

        const radius = virus.size + 30;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = radius + Math.random() * 20;
          virus.pellets.push({
            x: Math.cos(angle) * distance,
            y: Math.sin(angle) * distance,
            size: PELLET_SIZE,
            color: getRandomColor(),
          });
        }
      }

      // Start the game
      function startGame() {
        playerName = document.getElementById("playerName").value.trim();
        if (!playerName) playerName = "Player";

        // Get selected game mode
        gameMode = document
          .querySelector(".mode-btn.active")
          .getAttribute("data-mode");
        console.log("Game mode selected:", gameMode);

        // Reset to default settings if not in admin mode
        if (gameMode !== "admin") {
          resetAdminSettings();
        }

        // Rest of startGame function
        playerName = document.getElementById("playerName").value.trim();
        if (!playerName) playerName = "Player";

        gameMode = document
          .querySelector(".mode-btn.active")
          .getAttribute("data-mode");
        console.log("Game mode selected:", gameMode);

        if (
          gameStarted &&
          gameMode === "admin" &&
          document
            .querySelector(".mode-btn.active")
            .getAttribute("data-mode") !== "admin"
        ) {
          resetAdminSettings();
        }
        // Set default team if not selected
        if (gameMode === "teams" && !playerTeam) {
          playerTeam = "red";
        }

        if (
          gameStarted &&
          gameMode === "admin" &&
          document
            .querySelector(".mode-btn.active")
            .getAttribute("data-mode") !== "admin"
        ) {
          resetAdminSettings();
        }

        // Set the game mode from the UI
        gameMode = document
          .querySelector(".mode-btn.active")
          .getAttribute("data-mode");

        // Rest of startGame function
        playerName = document.getElementById("playerName").value.trim();
        if (!playerName) playerName = "Player";

        // Set default team if not selected
        if (gameMode === "teams" && !playerTeam) {
          playerTeam = "red";
        }
        // Reset team mass and history
        teamMass = { red: 0, green: 0, blue: 0 };

        // Start team history tracking for teams mode
        if (gameMode === "teams") {
          teamHistory = { red: [0], green: [0], blue: [0] };
          teamHighScores = { red: 0, green: 0, blue: 0 };

          // Update team history every few seconds
          if (historyUpdateInterval) {
            clearInterval(historyUpdateInterval);
          }

          historyUpdateInterval = setInterval(() => {
            for (const team in teamMass) {
              teamHistory[team].push(teamMass[team]);
              // Keep history length reasonable
              if (teamHistory[team].length > 20) {
                teamHistory[team].shift();
              }

              // Update high scores
              if (teamMass[team] > teamHighScores[team]) {
                teamHighScores[team] = teamMass[team];
              }
            }

            // Update team stats display
            updateTeamStats();
          }, 5000);
        }

        // Create player
        let playerColor =
          gameMode === "teams" ? TEAM_COLORS[playerTeam] : getRandomColor();

        // Random starting position
        const startX = (Math.random() - 0.5) * (WORLD_SIZE * 0.8);
        const startY = (Math.random() - 0.5) * (WORLD_SIZE * 0.8);

        player = {
          blobs: [
            {
              x: startX,
              y: startY,
              size: BASE_SIZE,
              mass: START_MASS,
              dx: 0,
              dy: 0,
              color: playerColor,
              createdAt: Date.now(),
            },
          ],
          name: playerName,
          totalMass: START_MASS,
          team: gameMode === "teams" ? playerTeam : null,
        };

        // Start rainbow mode if enabled
        if (rainbowMode) {
          if (rainbowInterval) {
            clearInterval(rainbowInterval);
          }

          rainbowInterval = setInterval(() => {
            // Change player color
            const color = getRandomColor();
            for (let i = 0; i < player.blobs.length; i++) {
              player.blobs[i].color = color;
            }
          }, 500);
        }

        // Create AI players
        blobs = []; // Clear existing blobs

        for (let i = 0; i < AI_COUNT; i++) {
          const aiName = AI_NAMES[Math.floor(Math.random() * AI_NAMES.length)];
          let aiColor, aiTeam;

          if (gameMode === "teams") {
            // Assign team evenly
            const teams = ["red", "green", "blue"];
            aiTeam = teams[i % 3];
            aiColor = TEAM_COLORS[aiTeam];
          } else {
            aiColor = COLORS[i % COLORS.length];
            aiTeam = null;
          }

          const x = (Math.random() - 0.5) * WORLD_SIZE;
          const y = (Math.random() - 0.5) * WORLD_SIZE;

          blobs.push({
            blobs: [
              {
                x: x,
                y: y,
                size: BASE_SIZE,
                mass: START_MASS,
                dx: 0,
                dy: 0,
                color: aiColor,
                createdAt: Date.now(),
              },
            ],
            name: aiName,
            totalMass: START_MASS,
            isAI: true,
            targetX: x,
            targetY: y,
            lastTargetChange: Date.now(),
            team: aiTeam,
          });
        }

        // Add some big pellets if enabled
        if (enableBigPellets) {
          for (let i = 0; i < PELLET_COUNT * 0.05; i++) {
            addBigPellet();
          }
        }

        // Hide menu, show game UI
        document.getElementById("menu").style.display = "none";
        document.getElementById("leaderboard").style.display = "block";
        document.getElementById("controls").style.display = "block";

        // Show team dominance and stats chart if in teams mode
        const adminPanel = document.getElementById("admin-panel");
        if (gameMode === "admin") {
          adminPanel.style.display = "block";
          console.log("Admin panel should be visible now");
        } else {
          adminPanel.style.display = "none";
        }

        // Show team UI if in teams mode
        if (gameMode === "teams") {
          document.getElementById("team-dominance").style.display = "block";
          document.getElementById("team-stats").style.display = "block";
        } else {
          document.getElementById("team-dominance").style.display = "none";
          document.getElementById("team-stats").style.display = "none";
        }

        gameStarted = true;
      }

      // Show admin panel in admin mode
      document.getElementById("admin-panel").style.display =
        gameMode === "admin" ? "block" : "none";

      gameStarted = true;

      // Main game loop
      function gameLoop(timestamp) {
        const deltaTime = timestamp - lastFrameTime;
        lastFrameTime = timestamp;

        update(deltaTime / 1000);
        render();

        requestAnimationFrame(gameLoop);
      }

      function updateGameState() {
        // If in admin mode, ensure panel is visible
        if (gameStarted && gameMode === "admin") {
          document.getElementById("admin-panel").style.display = "block";
        }
      }
      // Update game state
      function update(dt) {
        if (!gameStarted) return;

        if (player) {
          updatePlayer(dt);
        }

        updateAI(dt);
        updateDyingCells(dt);
        updateEjectedMass(dt);
        handleTeamBlobInteractions();
        checkCollisions();
        updateLeaderboard();
        updateGameState();
        // Update team dominance if in teams mode
        if (gameMode === "teams") {
          updateTeamDominance();
        }

        // Regenerate pellets if below threshold
        if (pellets.length < PELLET_COUNT / 2) {
          const newPellets = PELLET_COUNT - pellets.length;
          for (let i = 0; i < newPellets; i++) {
            addPellet();
          }
        }

        // Add occasional big pellet if enabled
        if (enableBigPellets && Math.random() < 0.01) {
          addBigPellet();
        }
      }

      // Update player position
      function updatePlayer(dt) {
        // Calculate direction based on keys
        const targetDx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
        const targetDy = (keys.down ? 1 : 0) - (keys.up ? 1 : 0);

        // Update each player blob
        for (let i = 0; i < player.blobs.length; i++) {
          const blob = player.blobs[i];

          // Normalize movement if diagonal
          const mag = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
          let moveX = targetDx;
          let moveY = targetDy;

          if (mag > 0) {
            moveX = targetDx / mag;
            moveY = targetDy / mag;
          }

          // Calculate speed based on mass (larger = slower)
          const speed =
            (MAX_SPEED - (blob.mass / 500) * (MAX_SPEED - MIN_SPEED)) *
            PLAYER_SPEED_MULTIPLIER;
          const finalSpeed = Math.max(MIN_SPEED, speed);

          // Set velocity
          blob.dx = moveX * finalSpeed;
          blob.dy = moveY * finalSpeed;

          // Update position
          blob.x += blob.dx;
          blob.y += blob.dy;

          // Keep player blob within world bounds
          blob.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.x));
          blob.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.y));
        }

        // Check if blobs can merge back together
        mergeBlobsIfPossible(player);

        // Update camera to center on player's center of mass
        if (player.blobs.length > 0) {
          let centerX = 0,
            centerY = 0,
            totalMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            centerX += player.blobs[i].x * player.blobs[i].mass;
            centerY += player.blobs[i].y * player.blobs[i].mass;
            totalMass += player.blobs[i].mass;
          }
          centerX /= totalMass;
          for (let i = 0; i < newPellets; i++) {
            addPellet();
          }
        }

        // Add occasional big pellet if enabled
        if (enableBigPellets && Math.random() < 0.01) {
          addBigPellet();
        }
      }

      // Update player position
      function updatePlayer(dt) {
        // Calculate direction based on keys
        const targetDx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
        const targetDy = (keys.down ? 1 : 0) - (keys.up ? 1 : 0);

        // Update each player blob
        for (let i = 0; i < player.blobs.length; i++) {
          const blob = player.blobs[i];

          // Normalize movement if diagonal
          const mag = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
          let moveX = targetDx;
          let moveY = targetDy;

          if (mag > 0) {
            moveX = targetDx / mag;
            moveY = targetDy / mag;
          }

          // Calculate speed based on mass (larger = slower)
          const speed =
            (MAX_SPEED - (blob.mass / 500) * (MAX_SPEED - MIN_SPEED)) *
            PLAYER_SPEED_MULTIPLIER;
          const finalSpeed = Math.max(MIN_SPEED, speed);

          // Set velocity
          blob.dx = moveX * finalSpeed;
          blob.dy = moveY * finalSpeed;

          // Update position
          blob.x += blob.dx;
          blob.y += blob.dy;

          // Keep player blob within world bounds
          blob.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.x));
          blob.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.y));
        }

        // Check if blobs can merge back together
        mergeBlobsIfPossible(player);

        // Update camera to center on player's center of mass
        if (player.blobs.length > 0) {
          let centerX = 0,
            centerY = 0,
            totalMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            centerX += player.blobs[i].x * player.blobs[i].mass;
            centerY += player.blobs[i].y * player.blobs[i].mass;
            totalMass += player.blobs[i].mass;
          }
          centerX /= totalMass;
          centerY /= totalMass;

          // Smooth camera movement
          camera.x += (centerX - camera.x) * 0.1;
          camera.y += (centerY - camera.y) * 0.1;

          // Adjust scale based on player's largest blob
          let maxMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            if (player.blobs[i].mass > maxMass) {
              maxMass = player.blobs[i].mass;
            }
          }

          const targetScale = Math.max(
            MIN_SCALE,
            Math.min(MAX_SCALE, 1 / (1 + maxMass / 1000))
          );
          camera.scale += (targetScale - camera.scale) * 0.1;
        }
      }

      // Update AI behavior
      function updateAI(dt) {
        for (let i = 0; i < blobs.length; i++) {
          if (!blobs[i].isAI) continue;

          const ai = blobs[i];

          // Check if we need to change target
          if (Date.now() - ai.lastTargetChange > 3000 + Math.random() * 5000) {
            // Random movement
            ai.targetX = ai.blobs[0].x + (Math.random() - 0.5) * 1000;
            ai.targetY = ai.blobs[0].y + (Math.random() - 0.5) * 1000;
            ai.lastTargetChange = Date.now();
          }

          // Check for nearby food
          let closestPellet = null;
          let closestPelletDist = 300; // Detection range

          for (let j = 0; j < pellets.length; j++) {
            const pellet = pellets[j];
            if (ai.blobs.length > 0) {
              const dist = distance(
                ai.blobs[0].x,
                ai.blobs[0].y,
                pellet.x,
                pellet.y
              );
              if (dist < closestPelletDist) {
                closestPellet = pellet;
                closestPelletDist = dist;
              }
            }
          }

          // Check for nearby players to chase
          let closestTarget = null;
          let closestTargetDist = 500; // Detection range

          // Check player blobs
          if (player) {
            // In teams mode, only chase players from different teams
            const canChasePlayer =
              gameMode !== "teams" || ai.team !== player.team;

            if (canChasePlayer && ai.blobs.length > 0) {
              for (let j = 0; j < player.blobs.length; j++) {
                const playerBlob = player.blobs[j];
                const dist = distance(
                  ai.blobs[0].x,
                  ai.blobs[0].y,
                  playerBlob.x,
                  playerBlob.y
                );

                // Only chase if AI is bigger
                if (
                  dist < closestTargetDist &&
                  ai.blobs[0].mass > playerBlob.mass * 1.2
                ) {
                  closestTarget = playerBlob;
                  closestTargetDist = dist;
                }
              }
            }
          }

          // Check other AI blobs
          for (let j = 0; j < blobs.length; j++) {
            if (i === j) continue; // Skip self

            // In teams mode, only chase AIs from different teams
            const canChaseAI =
              gameMode !== "teams" || ai.team !== blobs[j].team;

            if (
              canChaseAI &&
              ai.blobs.length > 0 &&
              blobs[j].blobs.length > 0
            ) {
              for (let k = 0; k < blobs[j].blobs.length; k++) {
                const otherBlob = blobs[j].blobs[k];
                const dist = distance(
                  ai.blobs[0].x,
                  ai.blobs[0].y,
                  otherBlob.x,
                  otherBlob.y
                );

                // Only chase if AI is bigger
                if (
                  dist < closestTargetDist &&
                  ai.blobs[0].mass > otherBlob.mass * 1.2
                ) {
                  closestTarget = otherBlob;
                  closestTargetDist = dist;
                }
              }
            }
          }

          // Set target priority: prey > food > random
          if (closestTarget) {
            ai.targetX = closestTarget.x;
            ai.targetY = closestTarget.y;
          } else if (closestPellet) {
            ai.targetX = closestPellet.x;
            ai.targetY = closestPellet.y;
          }

          // Move all AI blobs
          for (let j = 0; j < ai.blobs.length; j++) {
            const blob = ai.blobs[j];

            // Get direction to target
            const dx = ai.targetX - blob.x;
            const dy = ai.targetY - blob.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Normalize and set speed
            let moveX = 0,
              moveY = 0;
            if (dist > 0) {
              moveX = dx / dist;
              moveY = dy / dist;
            }

            // Calculate speed based on mass
            const speed =
              (MAX_SPEED - (blob.mass / 500) * (MAX_SPEED - MIN_SPEED)) *
              AI_SPEED_MULTIPLIER;
            const finalSpeed = Math.max(MIN_SPEED, speed);

            // Set velocity
            blob.dx = moveX * finalSpeed;
            blob.dy = moveY * finalSpeed;

            // Update position
            blob.x += blob.dx;
            blob.y += blob.dy;

            // Keep within world bounds
            blob.x = Math.max(
              -WORLD_SIZE / 2,
              Math.min(WORLD_SIZE / 2, blob.x)
            );
            blob.y = Math.max(
              -WORLD_SIZE / 2,
              Math.min(WORLD_SIZE / 2, blob.y)
            );
          }

          // Randomly split AI if it's large enough
          if (
            ai.blobs.length < 3 &&
            ai.blobs.length > 0 &&
            ai.blobs[0].mass > 100 &&
            Math.random() < 0.001
          ) {
            splitBlob(ai, 0);
          }

          // Check if blobs can merge back together
          mergeBlobsIfPossible(ai);
        }
      }

      // Update dying cells
      function updateDyingCells(dt) {
        for (let i = dyingCells.length - 1; i >= 0; i--) {
          const cell = dyingCells[i];

          // Update animation
          cell.opacity -= dt * 2; // Fade out
          cell.size += dt * 30; // Expand

          // Remove completed animations
          if (cell.opacity <= 0) {
            dyingCells.splice(i, 1);
          }
        }
      }

      // Check all game collisions
      function checkCollisions() {
        // Reset team mass for this frame
        teamMass = { red: 0, green: 0, blue: 0 };

        // Player blob collisions
        if (player) {
          for (let i = 0; i < player.blobs.length; i++) {
            const blob = player.blobs[i];

            // Check pellet collisions
            for (let j = pellets.length - 1; j >= 0; j--) {
              const pellet = pellets[j];
              if (circleCollision(blob, pellet)) {
                // Consume pellet
                blob.mass += pellet.mass || 1; // Regular pellet = 1 mass, big pellet = 100 mass
                blob.size = calculateSize(blob.mass);
                pellets.splice(j, 1);
              }
            }

            // Check experimental virus pellet collisions
            for (let j = 0; j < expViruses.length; j++) {
              const expVirus = expViruses[j];

              for (let k = expVirus.pellets.length - 1; k >= 0; k--) {
                const pellet = expVirus.pellets[k];
                const pelletAbs = {
                  x: expVirus.x + pellet.x,
                  y: expVirus.y + pellet.y,
                  size: pellet.size,
                };

                // Fix: Use absolute coordinates for collision check
                if (
                  circleCollision(
                    {
                      x: blob.x,
                      y: blob.y,
                      size: blob.size,
                    },
                    {
                      x: expVirus.x + pellet.x,
                      y: expVirus.y + pellet.y,
                      size: pellet.size,
                    }
                  )
                ) {
                  // Consume virus pellet
                  blob.mass += 1;
                  blob.size = calculateSize(blob.mass);
                  expVirus.pellets.splice(k, 1);
                }
              }

              // Replenish exp virus pellets
              if (expVirus.pellets.length < 10 && Math.random() < 0.05) {
                generateExpVirusPellets(expVirus, 1);
              }

              // Check if player blob is consumed by experimental virus
              if (
                blob.mass < expVirus.mass &&
                hasEnoughCoverage(expVirus, blob) &&
                !noCollision
              ) {
                // Add death animation
                addDeathAnimation(blob);

                // Blob is consumed by virus, generate more pellets
                generateExpVirusPellets(expVirus, Math.floor(blob.mass / 5));
                player.blobs.splice(i, 1);
                i--;
                if (player.blobs.length === 0) {
                  gameOver();
                }
                break;
              }
            }

            // Check green virus collisions - fixed to properly split without reducing mass
            for (let j = viruses.length - 1; j >= 0; j--) {
              const virus = viruses[j];

              if (
                blob.mass > virus.mass &&
                hasEnoughCoverage(blob, virus) &&
                !noCollision
              ) {
                // Virus splits player without reducing mass
                splitBlobByVirus(player, i);
                viruses.splice(j, 1);

                // Add new virus elsewhere
                viruses.push({
                  x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
                  y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
                  size: VIRUS_SIZE,
                  mass: 200,
                });

                break;
              }
            }

            // Check collisions with other players/AI
            for (let j = 0; j < blobs.length; j++) {
              const otherPlayer = blobs[j];

              // In teams mode, skip teammates
              if (gameMode === "teams" && player.team === otherPlayer.team) {
                continue;
              }

              for (let k = otherPlayer.blobs.length - 1; k >= 0; k--) {
                const otherBlob = otherPlayer.blobs[k];

                if (
                  circleCollision(blob, otherBlob) &&
                  hasEnoughCoverage(blob, otherBlob)
                ) {
                  // Check which blob is bigger
                  if (blob.mass > otherBlob.mass * 1.2) {
                    // Add death animation
                    addDeathAnimation(otherBlob);

                    // Player eats AI blob
                    blob.mass += otherBlob.mass;
                    blob.size = calculateSize(blob.mass);
                    otherPlayer.blobs.splice(k, 1);

                    // Check if AI is eliminated
                    if (otherPlayer.blobs.length === 0) {
                      blobs.splice(j, 1);
                      j--;

                      // Add a new AI
                      addNewAI();
                      break;
                    }
                  }
                }
              }
            }
          }

          // Update player total mass
          player.totalMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            player.totalMass += player.blobs[i].mass;
          }

          // Update team mass
          if (gameMode === "teams" && player.team) {
            teamMass[player.team] += player.totalMass;
          }
        }

        // AI blob collisions
        for (let i = 0; i < blobs.length; i++) {
          const ai = blobs[i];

          for (let j = 0; j < ai.blobs.length; j++) {
            const blob = ai.blobs[j];

            // Check pellet collisions
            for (let k = pellets.length - 1; k >= 0; k--) {
              const pellet = pellets[k];
              if (circleCollision(blob, pellet)) {
                // Consume pellet
                blob.mass += pellet.mass || 1;
                blob.size = calculateSize(blob.mass);
                pellets.splice(k, 1);
              }
            }

            // Check experimental virus pellet collisions
            for (let k = 0; k < expViruses.length; k++) {
              const expVirus = expViruses[k];

              for (let l = expVirus.pellets.length - 1; l >= 0; l--) {
                const pellet = expVirus.pellets[l];

                // Fix: Use absolute coordinates for collision check
                if (
                  circleCollision(
                    {
                      x: blob.x,
                      y: blob.y,
                      size: blob.size,
                    },
                    {
                      x: expVirus.x + pellet.x,
                      y: expVirus.y + pellet.y,
                      size: pellet.size,
                    }
                  )
                ) {
                  // Consume virus pellet
                  blob.mass += 1;
                  blob.size = calculateSize(blob.mass);
                  expVirus.pellets.splice(l, 1);
                }
              }

              // Check if AI blob is consumed by experimental virus
              if (
                blob.mass < expVirus.mass &&
                hasEnoughCoverage(expVirus, blob) &&
                !noCollision
              ) {
                // Add death animation
                addDeathAnimation(blob);

                // Blob is consumed by virus, generate more pellets
                generateExpVirusPellets(expVirus, Math.floor(blob.mass / 5));
                ai.blobs.splice(j, 1);
                j--;

                // Check if AI is eliminated
                if (ai.blobs.length === 0) {
                  blobs.splice(i, 1);
                  i--;

                  // Add a new AI
                  addNewAI();
                  break;
                }
                break;
              }
            }

            // Check green virus collisions - fixed to properly split without reducing mass
            for (let k = viruses.length - 1; k >= 0; k--) {
              const virus = viruses[k];

              if (
                blob.mass > virus.mass &&
                hasEnoughCoverage(blob, virus) &&
                !noCollision
              ) {
                // Virus splits AI without reducing mass
                splitBlobByVirus(ai, j);
                viruses.splice(k, 1);

                // Add new virus elsewhere
                viruses.push({
                  x: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
                  y: Math.random() * WORLD_SIZE - WORLD_SIZE / 2,
                  size: VIRUS_SIZE,
                  mass: 200,
                });

                break;
              }
            }

            // Check collisions with player
            if (player) {
              // In teams mode, skip teammates
              if (!(gameMode === "teams" && ai.team === player.team)) {
                for (let k = player.blobs.length - 1; k >= 0; k--) {
                  const playerBlob = player.blobs[k];

                  if (
                    circleCollision(blob, playerBlob) &&
                    hasEnoughCoverage(blob, playerBlob)
                  ) {
                    // Check which blob is bigger
                    if (blob.mass > playerBlob.mass * 1.2) {
                      // Add death animation
                      addDeathAnimation(playerBlob);

                      // AI eats player blob
                      blob.mass += playerBlob.mass;
                      blob.size = calculateSize(blob.mass);
                      player.blobs.splice(k, 1);

                      // Check if player is eliminated
                      if (player.blobs.length === 0) {
                        gameOver();
                        break;
                      }
                    }
                  }
                }
              }
            }

            // Check collisions with other AI
            for (let k = 0; k < blobs.length; k++) {
              if (i === k) continue; // Skip self

              const otherAI = blobs[k];

              // In teams mode, skip teammates
              if (gameMode === "teams" && ai.team === otherAI.team) {
                continue;
              }

              for (let l = otherAI.blobs.length - 1; l >= 0; l--) {
                const otherBlob = otherAI.blobs[l];

                if (
                  circleCollision(blob, otherBlob) &&
                  hasEnoughCoverage(blob, otherBlob)
                ) {
                  // Check which blob is bigger
                  if (blob.mass > otherBlob.mass * 1.2) {
                    // Add death animation
                    addDeathAnimation(otherBlob);

                    // AI eats other AI blob
                    blob.mass += otherBlob.mass;
                    blob.size = calculateSize(blob.mass);
                    otherAI.blobs.splice(l, 1);

                    // Check if other AI is eliminated
                    if (otherAI.blobs.length === 0) {
                      blobs.splice(k, 1);
                      if (k < i) i--;
                      k--;

                      // Add a new AI
                      addNewAI();
                      break;
                    }
                  }
                }
              }
            }
          }

          // Update AI total mass - only if the AI still exists
          if (ai && ai.blobs && ai.blobs.length > 0) {
            ai.totalMass = 0;
            for (let j = 0; j < ai.blobs.length; j++) {
              ai.totalMass += ai.blobs[j].mass;
            }

            // Update team mass
            if (gameMode === "teams" && ai.team) {
              teamMass[ai.team] += ai.totalMass;
            }
          }
        }
      }

      // Add death animation effect
      function addDeathAnimation(blob) {
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          dyingCells.push({
            x: blob.x + Math.cos(angle) * blob.size * 0.5,
            y: blob.y + Math.sin(angle) * blob.size * 0.5,
            size: blob.size * 0.3,
            opacity: 1.0,
            color: blob.color,
          });
        }
      }

      // Split a blob in half voluntarily (player pressing space)
      function splitBlob(entity, index) {
        const blob = entity.blobs[index];

        if (blob.mass < 20 || entity.blobs.length >= MAX_SPLITS) return;

        const newMass = blob.mass / 2;
        blob.mass = newMass;
        blob.size = calculateSize(blob.mass);

        // Enhanced split mechanics
        let angle;
        if (entity === player) {
          // Get angle based on movement direction
          angle = Math.atan2(blob.dy, blob.dx);
          if (blob.dx === 0 && blob.dy === 0) {
            // If not moving, base angle on mouse/key direction
            const targetDx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
            const targetDy = (keys.down ? 1 : 0) - (keys.up ? 1 : 0);
            if (targetDx === 0 && targetDy === 0) {
              // If no keys pressed, split in random direction
              angle = Math.random() * Math.PI * 2;
            } else {
              angle = Math.atan2(targetDy, targetDx);
            }
          }
        } else {
          angle = Math.atan2(entity.targetY - blob.y, entity.targetX - blob.x);
        }

        // Apply enhanced propulsion
        const speed = SPLIT_FORCE * (1 + blob.mass / 1000); // Bigger splits move faster
        const recoil = -speed * 0.3; // Add recoil to original blob

        // Update original blob
        blob.dx += Math.cos(angle) * recoil;
        blob.dy += Math.sin(angle) * recoil;

        // Position new blob at edge of original blob
        // This is key for fixing the overlap issue
        const spawnDistance = blob.size + calculateSize(newMass);
        const newX = blob.x + Math.cos(angle) * spawnDistance;
        const newY = blob.y + Math.sin(angle) * spawnDistance;

        // Create new blob with enhanced momentum
        const newBlob = {
          x: newX,
          y: newY,
          size: calculateSize(newMass),
          mass: newMass,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          color: blob.color,
          createdAt: Date.now(),
          momentumEndTime: Date.now() + 750, // Momentum lasts 750ms
          splitVelocity: speed, // Track initial split velocity
          splitAngle: angle, // Track split direction
        };

        entity.blobs.push(newBlob);
      }

      // Update player position - Add momentum handling
      function updatePlayer(dt) {
        // Calculate direction based on keys
        const targetDx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
        const targetDy = (keys.down ? 1 : 0) - (keys.up ? 1 : 0);

        // Update each player blob
        for (let i = 0; i < player.blobs.length; i++) {
          const blob = player.blobs[i];

          // Handle split momentum if active
          if (blob.momentumEndTime && Date.now() < blob.momentumEndTime) {
            // Calculate progress through momentum period (0 to 1)
            const progress =
              (Date.now() - blob.createdAt) /
              (blob.momentumEndTime - blob.createdAt);

            // Gradually reduce momentum based on progress
            const momentumFactor = 1 - progress;

            // Apply remaining momentum
            blob.x +=
              Math.cos(blob.splitAngle) *
              blob.splitVelocity *
              momentumFactor *
              dt;
            blob.y +=
              Math.sin(blob.splitAngle) *
              blob.splitVelocity *
              momentumFactor *
              dt;

            // If we're near the end of momentum, transition to normal movement
            if (progress > 0.7) {
              // Normalize movement if diagonal
              const mag = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
              let moveX = targetDx;
              let moveY = targetDy;

              if (mag > 0) {
                moveX = targetDx / mag;
                moveY = targetDy / mag;
              }

              // Calculate speed based on mass (larger = slower)
              const speed =
                (MAX_SPEED - (blob.mass / 500) * (MAX_SPEED - MIN_SPEED)) *
                PLAYER_SPEED_MULTIPLIER;
              const finalSpeed = Math.max(MIN_SPEED, speed);

              // Blend momentum and player control
              const blendFactor = (progress - 0.7) / 0.3; // Ranges from 0 to 1 during transition
              blob.dx =
                (1 - blendFactor) *
                  (Math.cos(blob.splitAngle) *
                    blob.splitVelocity *
                    momentumFactor) +
                blendFactor * (moveX * finalSpeed);
              blob.dy =
                (1 - blendFactor) *
                  (Math.sin(blob.splitAngle) *
                    blob.splitVelocity *
                    momentumFactor) +
                blendFactor * (moveY * finalSpeed);

              // Update position with blended movement
              blob.x += blob.dx * dt;
              blob.y += blob.dy * dt;
            }
          } else {
            // Normal movement once momentum is over
            // Normalize movement if diagonal
            const mag = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            let moveX = targetDx;
            let moveY = targetDy;

            if (mag > 0) {
              moveX = targetDx / mag;
              moveY = targetDy / mag;
            }

            // Calculate speed based on mass (larger = slower)
            const speed =
              (MAX_SPEED - (blob.mass / 500) * (MAX_SPEED - MIN_SPEED)) *
              PLAYER_SPEED_MULTIPLIER;
            const finalSpeed = Math.max(MIN_SPEED, speed);

            // Set velocity
            blob.dx = moveX * finalSpeed;
            blob.dy = moveY * finalSpeed;

            // Update position
            blob.x += blob.dx * dt;
            blob.y += blob.dy * dt;
          }

          // Keep player blob within world bounds
          blob.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.x));
          blob.y = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, blob.y));
        }

        // Check if blobs can merge back together
        mergeBlobsIfPossible(player);

        // Update camera to center on player's center of mass
        if (player.blobs.length > 0) {
          let centerX = 0,
            centerY = 0,
            totalMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            centerX += player.blobs[i].x * player.blobs[i].mass;
            centerY += player.blobs[i].y * player.blobs[i].mass;
            totalMass += player.blobs[i].mass;
          }
          centerX /= totalMass;
          centerY /= totalMass;

          // Smooth camera movement
          camera.x += (centerX - camera.x) * 0.1;
          camera.y += (centerY - camera.y) * 0.1;

          // Adjust scale based on player's largest blob
          let maxMass = 0;
          for (let i = 0; i < player.blobs.length; i++) {
            if (player.blobs[i].mass > maxMass) {
              maxMass = player.blobs[i].mass;
            }
          }

          const targetScale = Math.max(
            MIN_SCALE,
            Math.min(MAX_SCALE, 1 / (1 + maxMass / 1000))
          );
          camera.scale += (targetScale - camera.scale) * 0.1;
        }
      }

      // Split blob by virus (into many pieces)
      function splitBlobByVirus(entity, index) {
        const blob = entity.blobs[index];
        const originalMass = blob.mass;

        // Calculate number of splits based on mass
        const numSplits = Math.min(
          20,
          Math.max(2, Math.floor(originalMass / 10))
        );

        // Keep original mass, just split it
        const massPerBlob = originalMass / numSplits;
        blob.mass = massPerBlob;
        blob.size = calculateSize(blob.mass);

        // Create new blobs in all directions
        for (let i = 1; i < numSplits; i++) {
          // Only create new blobs if we're under the max limit
          if (entity.blobs.length >= MAX_SPLITS) break;

          const angle = (i / numSplits) * Math.PI * 2;
          const speed = SPLIT_FORCE * 0.8; // Slightly less force than manual split

          const newBlob = {
            x: blob.x,
            y: blob.y,
            size: calculateSize(massPerBlob),
            mass: massPerBlob,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            color: blob.color,
            createdAt: Date.now(),
          };

          entity.blobs.push(newBlob);
        }
      }

      // Check if blobs can merge back together
      function mergeBlobsIfPossible(entity) {
        for (let i = 0; i < entity.blobs.length; i++) {
          for (let j = i + 1; j < entity.blobs.length; j++) {
            const blob1 = entity.blobs[i];
            const blob2 = entity.blobs[j];

            // Check if enough time has passed since creation (30 seconds)
            if (
              Date.now() - blob1.createdAt < SPLIT_DELAY ||
              Date.now() - blob2.createdAt < SPLIT_DELAY
            ) {
              // Blobs can't merge yet, but we should still prevent overlap
              if (circleCollision(blob1, blob2)) {
                // Calculate direction vector between blobs
                const dx = blob2.x - blob1.x;
                const dy = blob2.y - blob1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0 && dist < blob1.size + blob2.size) {
                  // Calculate overlap amount
                  const overlap = (blob1.size + blob2.size - dist) / 2;

                  // Push blobs apart to prevent overlap
                  const pushX = (dx / dist) * overlap * 0.5;
                  const pushY = (dy / dist) * overlap * 0.5;

                  // Move both blobs to prevent overlap
                  blob1.x -= pushX;
                  blob1.y -= pushY;
                  blob2.x += pushX;
                  blob2.y += pushY;
                }
              }
              continue;
            }

            // Check if blobs are close enough to merge
            if (circleCollision(blob1, blob2)) {
              // Merge blobs - combination of mass with weighted position and velocity
              const totalMass = blob1.mass + blob2.mass;
              const ratio1 = blob1.mass / totalMass;
              const ratio2 = blob2.mass / totalMass;

              // Update position, weighted by mass
              blob1.x = blob1.x * ratio1 + blob2.x * ratio2;
              blob1.y = blob1.y * ratio1 + blob2.y * ratio2;

              // Update velocity, weighted by mass
              blob1.dx = blob1.dx * ratio1 + blob2.dx * ratio2;
              blob1.dy = blob1.dy * ratio1 + blob2.dy * ratio2;

              // Update mass and size
              blob1.mass = totalMass;
              blob1.size = calculateSize(totalMass);

              // Remove second blob
              entity.blobs.splice(j, 1);
              j--;
            }
          }
        }
      }

      function handleTeamBlobInteractions() {
        // Only relevant in teams mode
        if (gameMode !== "teams") return;

        // For player blobs, check against all team member blobs
        if (player) {
          for (let i = 0; i < player.blobs.length; i++) {
            const playerBlob = player.blobs[i];

            // Check against all AI blobs from same team
            for (let j = 0; j < blobs.length; j++) {
              const ai = blobs[j];

              // Skip if not same team
              if (ai.team !== player.team) continue;

              for (let k = 0; k < ai.blobs.length; k++) {
                const aiBlob = ai.blobs[k];

                // Check for collision
                if (circleCollision(playerBlob, aiBlob)) {
                  // Calculate direction vector between blobs
                  const dx = aiBlob.x - playerBlob.x;
                  const dy = aiBlob.y - playerBlob.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);

                  if (dist > 0 && dist < playerBlob.size + aiBlob.size) {
                    // Calculate overlap amount
                    const overlap = (playerBlob.size + aiBlob.size - dist) / 2;

                    // Push blobs apart to prevent overlap
                    const pushX = (dx / dist) * overlap * 0.5;
                    const pushY = (dy / dist) * overlap * 0.5;

                    // Move both blobs to prevent overlap
                    playerBlob.x -= pushX;
                    playerBlob.y -= pushY;
                    aiBlob.x += pushX;
                    aiBlob.y += pushY;
                  }
                }
              }
            }
          }
        }

        // For AI team blobs against other AI team blobs
        for (let i = 0; i < blobs.length; i++) {
          const ai1 = blobs[i];

          // Skip if no team
          if (!ai1.team) continue;

          for (let j = i + 1; j < blobs.length; j++) {
            const ai2 = blobs[j];

            // Skip if not same team
            if (ai1.team !== ai2.team) continue;

            // Check all blob pairs
            for (let k = 0; k < ai1.blobs.length; k++) {
              const blob1 = ai1.blobs[k];

              for (let l = 0; l < ai2.blobs.length; l++) {
                const blob2 = ai2.blobs[l];

                // Check for collision
                if (circleCollision(blob1, blob2)) {
                  // Calculate direction vector between blobs
                  const dx = blob2.x - blob1.x;
                  const dy = blob2.y - blob1.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);

                  if (dist > 0 && dist < blob1.size + blob2.size) {
                    // Calculate overlap amount
                    const overlap = (blob1.size + blob2.size - dist) / 2;

                    // Push blobs apart to prevent overlap
                    const pushX = (dx / dist) * overlap * 0.5;
                    const pushY = (dy / dist) * overlap * 0.5;

                    // Move both blobs to prevent overlap
                    blob1.x -= pushX;
                    blob1.y -= pushY;
                    blob2.x += pushX;
                    blob2.y += pushY;
                  }
                }
              }
            }
          }
        }
      }

      // Eject mass (E key)
      function ejectMass(entity, index) {
        const blob = entity.blobs[index];

        if (blob.mass <= 20) return;

        // Calculate direction
        let angle;
        if (entity === player) {
          // If player has movement direction, use that
          if (blob.dx !== 0 || blob.dy !== 0) {
            angle = Math.atan2(blob.dy, blob.dx);
          } else {
            // Otherwise use key direction
            const targetDx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
            const targetDy = (keys.down ? 1 : 0) - (keys.up ? 1 : 0);

            if (targetDx === 0 && targetDy === 0) {
              // If no keys pressed, eject forward (up)
              angle = -Math.PI / 2;
            } else {
              angle = Math.atan2(targetDy, targetDx);
            }
          }
        } else {
          angle = Math.atan2(entity.targetY - blob.y, entity.targetX - blob.x);
        }

        // Enhanced pellet properties
        const ejectedMass = Math.min(blob.mass * 0.05, 10); // Eject up to 5% mass
        const pelletSize = PELLET_SIZE * 1.5;
        const pelletSpeed = 12; // Increased speed for better visibility

        // Position pellet at edge of blob (not inside)
        const spawnDistance = blob.size + pelletSize;
        const pelletX = blob.x + Math.cos(angle) * spawnDistance;
        const pelletY = blob.y + Math.sin(angle) * spawnDistance;

        // Create ejected mass pellet with momentum
        pellets.push({
          x: pelletX,
          y: pelletY,
          dx: Math.cos(angle) * pelletSpeed,
          dy: Math.sin(angle) * pelletSpeed,
          size: pelletSize,
          mass: ejectedMass,
          color: blob.color,
          isBig: false,
          ejectedAt: Date.now(),
          isEjected: true, // Flag to treat ejected mass differently
        });

        // Reduce blob mass and apply recoil
        blob.mass -= ejectedMass;
        blob.size = calculateSize(blob.mass);
        blob.dx -= Math.cos(angle) * 1.0; // Increased recoil for better feel
        blob.dy -= Math.sin(angle) * 1.0;
      }

      // Add ejected mass physics to the update function
      function updateEjectedMass(dt) {
        for (let i = 0; i < pellets.length; i++) {
          const pellet = pellets[i];

          // Only process ejected pellets with momentum
          if (
            pellet.isEjected &&
            (pellet.dx !== undefined || pellet.dy !== undefined)
          ) {
            // Update position based on velocity
            pellet.x += pellet.dx * dt;
            pellet.y += pellet.dy * dt;

            // Apply friction to gradually slow down ejected mass
            const friction = 0.95;
            pellet.dx *= friction;
            pellet.dy *= friction;

            // Stop movement after it's slow enough
            if (Math.abs(pellet.dx) < 0.1 && Math.abs(pellet.dy) < 0.1) {
              pellet.dx = 0;
              pellet.dy = 0;
            }

            // Keep pellets within world bounds
            pellet.x = Math.max(
              -WORLD_SIZE / 2,
              Math.min(WORLD_SIZE / 2, pellet.x)
            );
            pellet.y = Math.max(
              -WORLD_SIZE / 2,
              Math.min(WORLD_SIZE / 2, pellet.y)
            );
          }
        }
      }

      // Add a new AI player
      function addNewAI() {
        const aiName = AI_NAMES[Math.floor(Math.random() * AI_NAMES.length)];
        let aiColor, aiTeam;

        if (gameMode === "teams") {
          // Balance teams by adding to the lowest team
          const teamCounts = countTeamMembers();
          let lowestTeam = "red";

          if (teamCounts.green < teamCounts[lowestTeam]) {
            lowestTeam = "green";
          }
          if (teamCounts.blue < teamCounts[lowestTeam]) {
            lowestTeam = "blue";
          }

          aiTeam = lowestTeam;
          aiColor = TEAM_COLORS[aiTeam];
        } else {
          aiColor = COLORS[Math.floor(Math.random() * COLORS.length)];
          aiTeam = null;
        }

        const x = (Math.random() - 0.5) * WORLD_SIZE;
        const y = (Math.random() - 0.5) * WORLD_SIZE;

        blobs.push({
          blobs: [
            {
              x: x,
              y: y,
              size: BASE_SIZE,
              mass: START_MASS,
              dx: 0,
              dy: 0,
              color: aiColor,
              createdAt: Date.now(),
            },
          ],
          name: aiName,
          totalMass: START_MASS,
          isAI: true,
          targetX: x,
          targetY: y,
          lastTargetChange: Date.now(),
          team: aiTeam,
        });
      }

      // Count members in each team
      function countTeamMembers() {
        const teamCounts = { red: 0, green: 0, blue: 0 };

        // Count AI
        for (let i = 0; i < blobs.length; i++) {
          if (blobs[i].team) {
            teamCounts[blobs[i].team]++;
          }
        }

        // Count player
        if (player && player.team) {
          teamCounts[player.team]++;
        }

        return teamCounts;
      }

      // Update leaderboard
      function updateLeaderboard() {
        const leaderboardList = document.getElementById("leaderboardList");
        leaderboardList.innerHTML = "";

        // Combine player and AI into one array
        let allPlayers = [...blobs];
        if (player) {
          allPlayers.push(player);
        }

        // Sort by total mass
        allPlayers.sort((a, b) => b.totalMass - a.totalMass);

        // Find player position
        let playerPosition = -1;
        if (player) {
          playerPosition = allPlayers.findIndex((p) => p === player) + 1;
          document.getElementById(
            "playerPosition"
          ).textContent = `Your Position: ${playerPosition}`;
          document.getElementById("playerPosition").style.display = "block";
        } else {
          document.getElementById("playerPosition").style.display = "none";
        }

        // Display top 10
        for (let i = 0; i < Math.min(10, allPlayers.length); i++) {
          const li = document.createElement("li");
          const nameSpan = document.createElement("span");
          const scoreSpan = document.createElement("span");

          // Create team indicator if in teams mode
          if (gameMode === "teams" && allPlayers[i].team) {
            const teamIndicator = document.createElement("span");
            teamIndicator.className = "team-indicator";
            teamIndicator.style.backgroundColor =
              TEAM_COLORS[allPlayers[i].team];
            nameSpan.appendChild(teamIndicator);
          }

          nameSpan.innerHTML += `${i + 1}. ${allPlayers[i].name}`;
          scoreSpan.textContent = Math.floor(allPlayers[i].totalMass);

          // Highlight player
          if (allPlayers[i] === player) {
            li.style.fontWeight = "bold";
            li.style.color = player.blobs[0]?.color || "#000";
          }

          li.appendChild(nameSpan);
          li.appendChild(scoreSpan);
          leaderboardList.appendChild(li);
        }
      }

      // Update team dominance chart
      function updateTeamDominance() {
        // Calculate total mass and percentages
        const totalMass = teamMass.red + teamMass.green + teamMass.blue;
        const redPercent =
          totalMass > 0 ? (teamMass.red / totalMass) * 100 : 33.33;
        const greenPercent =
          totalMass > 0 ? (teamMass.green / totalMass) * 100 : 33.33;
        const bluePercent =
          totalMass > 0 ? (teamMass.blue / totalMass) * 100 : 33.33;

        // Update pie chart
        const pieChart = document.getElementById("team-pie-chart");
        pieChart.innerHTML = createPieChart(
          redPercent,
          greenPercent,
          bluePercent
        );
      }

      // Update team stats bar graph
      function updateTeamStats() {
        const teamBars = document.getElementById("team-bars");
        teamBars.innerHTML = "";

        // Find the maximum value for scaling
        const maxValue = Math.max(
          teamHighScores.red,
          teamHighScores.green,
          teamHighScores.blue,
          teamMass.red,
          teamMass.green,
          teamMass.blue
        );

        // Add current bars
        addTeamBar(teamBars, "Current Red", teamMass.red, maxValue, "red");
        addTeamBar(
          teamBars,
          "Current Green",
          teamMass.green,
          maxValue,
          "green"
        );
        addTeamBar(teamBars, "Current Blue", teamMass.blue, maxValue, "blue");

        // Add separator
        const separator = document.createElement("div");
        separator.style.height = "1px";
        separator.style.background = "#ddd";
        separator.style.margin = "10px 0";
        teamBars.appendChild(separator);

        // Add high score bars
        addTeamBar(teamBars, "Red High", teamHighScores.red, maxValue, "red");
        addTeamBar(
          teamBars,
          "Green High",
          teamHighScores.green,
          maxValue,
          "green"
        );
        addTeamBar(
          teamBars,
          "Blue High",
          teamHighScores.blue,
          maxValue,
          "blue"
        );
      }

      // Add a team bar to the stats display
      function addTeamBar(container, label, value, maxValue, color) {
        const teamBar = document.createElement("div");
        teamBar.style.width = Math.max(5, (value / maxValue) * 100) + "%";
        teamBar.className = "team-bar";
        teamBar.style.backgroundColor = TEAM_COLORS[color] || color;

        const teamBarLabel = document.createElement("span");
        teamBarLabel.className = "team-bar-label";
        teamBarLabel.textContent = `${label}: ${Math.floor(value)}`;
        teamBar.appendChild(teamBarLabel);

        const teamBarContainer = document.createElement("div");
        teamBarContainer.style.height = "20px";
        teamBarContainer.style.marginBottom = "5px";
        teamBarContainer.style.overflow = "hidden";
        teamBarContainer.appendChild(teamBar);

        container.appendChild(teamBarContainer);
      }

      // Create SVG pie chart
      function createPieChart(redPercent, greenPercent, bluePercent) {
        // Calculate angles
        const redAngle = (redPercent / 100) * 360;
        const greenAngle = (greenPercent / 100) * 360;
        const blueAngle = (bluePercent / 100) * 360;

        // Create SVG paths
        let paths = "";
        let currentAngle = 0;

        // Red slice
        paths += createPieSlice(currentAngle, currentAngle + redAngle, "red");
        currentAngle += redAngle;

        // Green slice
        paths += createPieSlice(
          currentAngle,
          currentAngle + greenAngle,
          "green"
        );
        currentAngle += greenAngle;

        // Blue slice
        paths += createPieSlice(currentAngle, currentAngle + blueAngle, "blue");

        return `<svg viewBox="0 0 100 100">
                      <circle cx="50" cy="50" r="48" fill="white" stroke="#ddd" stroke-width="1"></circle>
                      ${paths}
                      <text x="50" y="35" text-anchor="middle" font-size="10" font-weight="bold">Red: ${Math.round(
                        redPercent
                      )}%</text>
                      <text x="50" y="50" text-anchor="middle" font-size="10" font-weight="bold">Green: ${Math.round(
                        greenPercent
                      )}%</text>
                      <text x="50" y="65" text-anchor="middle" font-size="10" font-weight="bold">Blue: ${Math.round(
                        bluePercent
                      )}%</text>
                  </svg>`;
      }

      // Create a pie slice path
      function createPieSlice(startAngle, endAngle, color) {
        if (endAngle - startAngle === 0) return "";

        const radius = 48;
        const cx = 50;
        const cy = 50;

        // Convert angles to radians
        const startRad = ((startAngle - 90) * Math.PI) / 180;
        const endRad = ((endAngle - 90) * Math.PI) / 180;

        // Calculate points
        const x1 = cx + radius * Math.cos(startRad);
        const y1 = cy + radius * Math.sin(startRad);
        const x2 = cx + radius * Math.cos(endRad);
        const y2 = cy + radius * Math.sin(endRad);

        // Create arc flag
        const largeArcFlag = endAngle - startAngle > 180 ? 1 : 0;

        // Create path
        return `<path d="M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z" fill="${color}" opacity="0.7"></path>`;
      }

      // Game over
      function gameOver() {
        gameStarted = false;

        // Show menu
        document.getElementById("menu").style.display = "block";
        document.getElementById("menu").querySelector("h1").textContent =
          "Game Over";
        document.getElementById("playButton").textContent = "Play Again";

        // Stop rainbow mode if active
        if (rainbowInterval) {
          clearInterval(rainbowInterval);
          rainbowInterval = null;
        }

        // Stop team history tracking
        if (historyUpdateInterval) {
          clearInterval(historyUpdateInterval);
          historyUpdateInterval = null;
        }

        // Reset game state
        player = null;
      }

      // Render game
      function render() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Set camera transform
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(camera.scale, camera.scale);
        ctx.translate(-camera.x, -camera.y);

        // Draw grid
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(200, 200, 200, 0.5)";
        ctx.beginPath();

        // Vertical lines
        for (let x = -WORLD_SIZE / 2; x <= WORLD_SIZE / 2; x += GRID_SPACING) {
          ctx.moveTo(x, -WORLD_SIZE / 2);
          ctx.lineTo(x, WORLD_SIZE / 2);
        }

        // Horizontal lines
        for (let y = -WORLD_SIZE / 2; y <= WORLD_SIZE / 2; y += GRID_SPACING) {
          ctx.moveTo(-WORLD_SIZE / 2, y);
          ctx.lineTo(WORLD_SIZE / 2, y);
        }

        ctx.stroke();

        // Draw world border
        ctx.lineWidth = 5;
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.strokeRect(
          -WORLD_SIZE / 2,
          -WORLD_SIZE / 2,
          WORLD_SIZE,
          WORLD_SIZE
        );

        // Draw pellets
        for (let i = 0; i < pellets.length; i++) {
          const pellet = pellets[i];

          // Check if pellet is in viewport
          if (isInViewport(pellet)) {
            // Special styling for big pellets
            if (pellet.isBig) {
              // Draw glow effect
              ctx.beginPath();
              ctx.arc(pellet.x, pellet.y, pellet.size + 5, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255, 255, 0, 0.2)";
              ctx.fill();

              // Draw pellet
              drawCircle(pellet.x, pellet.y, pellet.size, pellet.color);

              // Draw border
              ctx.beginPath();
              ctx.arc(pellet.x, pellet.y, pellet.size, 0, Math.PI * 2);
              ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
              ctx.lineWidth = 2;
              ctx.stroke();
            } else {
              drawCircle(pellet.x, pellet.y, pellet.size, pellet.color);
            }
          }
        }

        // Draw viruses
        for (let i = 0; i < viruses.length; i++) {
          const virus = viruses[i];

          // Check if virus is in viewport
          if (isInViewport(virus)) {
            drawVirus(virus.x, virus.y, virus.size, "green");
          }
        }

        // Draw experimental viruses
        for (let i = 0; i < expViruses.length; i++) {
          const virus = expViruses[i];

          // Check if virus is in viewport
          if (isInViewport(virus)) {
            // Draw exp virus
            drawCircle(virus.x, virus.y, virus.size, "purple");

            // Draw pellets around virus
            for (let j = 0; j < virus.pellets.length; j++) {
              const pellet = virus.pellets[j];
              drawCircle(
                virus.x + pellet.x,
                virus.y + pellet.y,
                pellet.size,
                pellet.color
              );
            }
          }
        }

        // Draw dying cells (death animation)
        for (let i = 0; i < dyingCells.length; i++) {
          const cell = dyingCells[i];
          ctx.globalAlpha = cell.opacity;
          drawCircle(cell.x, cell.y, cell.size, cell.color);
          ctx.globalAlpha = 1.0;
        }

        // Draw AI blobs
        for (let i = 0; i < blobs.length; i++) {
          const ai = blobs[i];

          for (let j = 0; j < ai.blobs.length; j++) {
            const blob = ai.blobs[j];

            // Check if blob is in viewport
            if (isInViewport(blob)) {
              drawBlob(blob.x, blob.y, blob.size, blob.color, ai.name);
            }
          }
        }

        // Draw player blobs
        if (player) {
          for (let i = 0; i < player.blobs.length; i++) {
            const blob = player.blobs[i];
            drawBlob(blob.x, blob.y, blob.size, blob.color, player.name);
          }
        }

        // Restore canvas transform
        ctx.restore();
      }

      // Draw circle
      function drawCircle(x, y, radius, color) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();

        // Add highlight effect
        ctx.beginPath();
        ctx.arc(
          x - radius * 0.3,
          y - radius * 0.3,
          radius * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.fill();

        // Draw name
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Scale text based on blob size
        const fontSize = Math.max(12, Math.min(24, radius / 2));
        ctx.font = `bold ${fontSize}px Arial`;

        // Draw text with stroke
        ctx.strokeText(name, x, y);
        ctx.fillText(name, x, y);

        // Draw mass display for admin mode
        if (gameMode === "admin") {
          ctx.fillStyle = "white";
          ctx.font = `${Math.max(10, fontSize * 0.7)}px Arial`;
          ctx.fillText(`${Math.floor(radius)}`, x, y + fontSize);
        }
        Style = color;
        ctx.fill();
      }

      // Draw blob with name
      function drawBlob(x, y, radius, color, name) {
        // Draw blob circle with gradient
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, lightenColor(color, 30));
        gradient.addColorStop(1, color);

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Add highlight effect
        ctx.beginPath();
        ctx.arc(
          x - radius * 0.3,
          y - radius * 0.3,
          radius * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.fill();

        // Draw name
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Scale text based on blob size
        const fontSize = Math.max(12, Math.min(24, radius / 2));
        ctx.font = `bold ${fontSize}px Arial`;

        // Draw text with stroke
        ctx.strokeText(name, x, y);
        ctx.fillText(name, x, y);

        // Draw mass display for admin mode
        if (gameMode === "admin") {
          ctx.fillStyle = "white";
          ctx.font = `${Math.max(10, fontSize * 0.7)}px Arial`;
          ctx.fillText(`${Math.floor(radius)}`, x, y + fontSize);
        }
      }

      // Draw virus (with spikes)
      function drawVirus(x, y, radius, color) {
        const spikes = 12;
        const innerRadius = radius * 0.9;
        const outerRadius = radius * 1.1;

        ctx.beginPath();

        for (let i = 0; i < spikes * 2; i++) {
          const angle = (i / (spikes * 2)) * Math.PI * 2;
          const r = i % 2 === 0 ? outerRadius : innerRadius;
          const px = x + Math.cos(angle) * r;
          const py = y + Math.sin(angle) * r;

          if (i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }

        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();

        // Add glow effect in admin mode
        if (gameMode === "admin") {
          ctx.beginPath();
          ctx.arc(x, y, radius * 1.2, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
          ctx.fill();
        }
      }

      // Check if object is in viewport
      function isInViewport(obj) {
        const viewportLeft = camera.x - canvas.width / 2 / camera.scale;
        const viewportRight = camera.x + canvas.width / 2 / camera.scale;
        const viewportTop = camera.y - canvas.height / 2 / camera.scale;
        const viewportBottom = camera.y + canvas.height / 2 / camera.scale;

        // Add a small buffer for large objects
        const buffer = obj.size || 0;

        return (
          obj.x + buffer > viewportLeft &&
          obj.x - buffer < viewportRight &&
          obj.y + buffer > viewportTop &&
          obj.y - buffer < viewportBottom
        );
      }

      // Calculate blob size from mass
      function calculateSize(mass) {
        return Math.sqrt(mass) * 4 + MIN_BLOB_SIZE;
      }

      // Check collision between two circles
      function circleCollision(circle1, circle2) {
        const dx = circle1.x - circle2.x;
        const dy = circle1.y - circle2.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < circle1.size + circle2.size;
      }

      // Check if one circle has enough coverage of another to eat it
      function hasEnoughCoverage(eater, food) {
        // First check if they're colliding at all
        if (!circleCollision(eater, food)) {
          return false;
        }

        // Calculate the distance between the centers
        const dx = eater.x - food.x;
        const dy = eater.y - food.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate how much of the food is covered by the eater
        // Distance threshold is the percentage of the food's diameter that must be covered
        // COVERAGE_REQUIRED of 0.5 means 50% of the food must be covered
        const distanceThreshold = food.size * (1 - COVERAGE_REQUIRED);

        // Check if eater covers enough of the food
        return distance < eater.size - distanceThreshold;
      }

      // Calculate distance between two points
      function distance(x1, y1, x2, y2) {
        const dx = x1 - x2;
        const dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Get random color
      function getRandomColor() {
        return COLORS[Math.floor(Math.random() * COLORS.length)];
      }

      // Lighten a color
      function lightenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const r = Math.min(255, (num >> 16) + amt);
        const g = Math.min(255, ((num >> 8) & 0x00ff) + amt);
        const b = Math.min(255, (num & 0x0000ff) + amt);
        return `#${((1 << 24) | (r << 16) | (g << 8) | b)
          .toString(16)
          .slice(1)}`;
      }

      // Handle key down
      function handleKeyDown(e) {
        if (!gameStarted || !player) return;

        switch (e.key.toLowerCase()) {
          case "w":
          case "arrowup":
            keys.up = true;
            break;
          case "a":
          case "arrowleft":
            keys.left = true;
            break;
          case "s":
          case "arrowdown":
            keys.down = true;
            break;
          case "d":
          case "arrowright":
            keys.right = true;
            break;
          case "e":
            // Eject mass on 'e' key
            if (!e.repeat) {
              // Eject mass from all player blobs
              for (let i = 0; i < player.blobs.length; i++) {
                ejectMass(player, i);
              }
            }
            break;
          case " ":
            // Split on spacebar if not already pressed
            if (!e.repeat) {
              // Split all player blobs if under maximum
              const numBlobs = player.blobs.length;
              if (numBlobs < MAX_SPLITS) {
                // Iterate in reverse to avoid index issues when adding blobs
                for (let i = numBlobs - 1; i >= 0; i--) {
                  if (player.blobs.length < MAX_SPLITS) {
                    splitBlob(player, i);
                  }
                }
              }
            }
            break;
        }
      }

      // Handle key up
      function handleKeyUp(e) {
        switch (e.key.toLowerCase()) {
          case "w":
          case "arrowup":
            keys.up = false;
            break;
          case "a":
          case "arrowleft":
            keys.left = false;
            break;
          case "s":
          case "arrowdown":
            keys.down = false;
            break;
          case "d":
          case "arrowright":
            keys.right = false;
            break;
        }
      }

      // Start the game when loaded
      window.addEventListener("load", init);
    </script>
  </body>
</html>
